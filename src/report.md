---
documentclass: extarticle
papersize: a4
geometry: "left=25mm,right=10mm,top=20mm,bottom=20mm"

fontsize: 14pt
listings: true
indent: true
codeBlockCaptions: true
colorlinks: false
link-citations: true

mainfont: Times New Roman
monofont: DejaVu Sans Mono
mathfont: XITS Math
lang: ru-RU
babel-lang: russian

figPrefix: 
  - рис.
  - рис.
tblPrefix: 
  - табл.
  - табл.
toc-title: Оглавление

# Comment out if title is not needed
include-before: |
  ```{=latex}
  \includepdf[pages={1}]{src/title.pdf}
  ```
---

\pagebreak
# Введение {#sec:introduction -}

Разработка встраиваемых систем лежит в основе многих современных технологических 
направлений: от телекоммуникационных сетей и промышленного оборудования, 
до умного дома и беспилотных автомобилей. Если раньше под встраиваемыми системами
понимали только небольшие микроконтроллеры, для которых приходилось писать программы
на ассемблере, то сейчас многие устройства работают под управлением полноценной
операционной системы [@сигаев2000операционные], и все больше программного обеспечения 
пишется на высокоуровневых языках программирования с управляемой средой, таких как 
Java [@courington2012getting], Python [@donat2014learn] и C# [@caracas2009mote].
При этом проблема ограниченности ресурсов до сих пор остается актуальной для
встраиваемых систем, и ее решение требует эффективной реализации языков 
программирования и их сред исполнения.

<!-- Так все больше реализаций языков программирования переходят к полной или частичной
статической компиляции приложения от более распространенной в серверных решениях
just-in-time (JIT) компиляции. Уменьшение компиляции на устройстве
позволяет снизить издержки по памяти, время старта, а также энергопотребление
встраиваемой системы. Однако статическая компиляция имеет один существенный недостаток
для применения на встраиваемых устройствах --- размер исполняемого файла на диске. -->

<!-- Metadata (size, AOT) -->

В частности, требуется эффективная генерация служебных метаданных, которые требуются
управляемой среде для эффективного исполнения кода программы. Эти метаданные представляют собой 
низкоуровневые структуры данных, вычисленные в результате компиляции программы, 
которые используются во время исполнения для поддержки таких возможностей, 
как динамическая диспетчеризация вызовов, проверки соответствия типа и точная сборка мусора. 
Однако размер порождаемых служебных метаданных велик и сравним с суммарным размером 
машинного кода программы [^intro-scala-size].
Из-за этого при статической компиляции программы, когда все метаданные пишутся в 
исполняемый файл, неоправданно увеличивается размер файла на диске.

[^intro-scala-size]: В качестве примера рассмотрим стандартную библиотеку
для языка программирования Scala версии 2.13.0, включающую в себя около 2500
классов и интерфейсов. Если статически скомпилировать эту библиотеку, то на выходе
получится исполняемый файл размером в 5\ MB, из которых 2\ MB (40\ %) занимают таблицы
виртуальных и интерфейсных методов.

<!-- VMT/IMT -->

Одними из самых крупных структур служебных метаданных являются таблицы виртуальных
и интерфейсных методов, которые используются для реализации динамической диспетчеризации
полиморфных вызовов в объектно-ориентированных языках с интерфейсным наследованием
(например, Java [@gosling2000java] и C# [@hejlsberg2003c]).
В этих языках, одиночное наследование классов позволяет эффективно реализовать 
виртуальные вызовы с помощью таблицы виртуальных методов, которая создается для 
каждого класса. Однако в случае множественного наследования интерфейсов, 
таких таблиц требуется несколько --- по одной на каждый интерфейс, реализуемый классом. 
Из-за этого возникает избыточность информации между ячейками разных таблиц, 
что и приводит к увеличению суммарного размера метаданных и, как следствие, 
исполняемого файла.

<!-- Existing modifications -->

Большинство существующих реализаций таблиц интерфейсных методов жертвуют размером
таблиц в пользу производительности. Так, например, реализации в CACAO [@cacao2021online]
и SableVM [@sable2021online], используют большие разреженные таблицы 
[@krall1997cacao; @gagnon2001sable], требующие 
довольно трудоемкого процесса назначения глобальных номеров методам
[@cox1986object; @dixon1989fast; @andre1992optimizing; @vitek1996compact], без которого размер
таблиц может неконтролируемо возрастать. В Jikes RVM [@jikes2021online] 
единственная интерфейсная таблица, несмотря на фиксированный размер, также 
может неконтролируемо расти за счет динамически генерируемых процедур разрешения
конфликтов [@deutsch1984efficient]. 

Большее внимание проблеме размера таблиц было уделено в системе Marmot [@fitzgerald2000marmot],
в которой используется схема вложенной раскладки интерфейсных таблиц, позволяющая
уменьшить избыточность информации между ними. Однако, как отмечают сами авторы, 
данный подход не всегда дает уменьшение размера, и иногда может наоборот, увеличить 
суммарный размер таблиц. Аналогичная схема была реализована в SHAP [@preusser2011increasing] 
вместе с дополнительными оптимизациями скорости интерфейсного вызова [@preusser2007enabling].

Ни одна из существующих реализаций не дает гарантированного уменьшения размера таблиц
по сравнению с базовой реализацией, что может оказаться неприемлемо при исполнении
программы на встраиваемых системах. На разрешение данной проблемы и направлено 
диссертационное исследование.

<!-- Thesis overview -->

<!-- В данной работе предлагается новый подход к генерации таблиц виртуальных и
интерфейсных методов, позволяющий минимизировать суммарный размер таблиц при 
статической компиляции программы. Подход состоит из двух независимых этапов:

- уменьшение внутриклассовой избыточности с помощью оптимизирующей раскладки
таблиц интерфейсных методов внутри таблицы виртуальных методов;
- уменьшение межклассовой избыточности с помощью разностного кодирования таблиц
в исполняемом файле.

Предложенное решение было реализовано и апробировано в экспериментальной сборке
Huawei JDK с поддержкой статической компиляции. В главе\ [-@sec:background] 
дается классификация метаданных в управляемой среде и описание структур таблиц 
виртуальных и интерфейсных методов. Затем ставится задача минимизации суммарного
размера таблиц, определяя два основных вида избыточности данных в них, и
проводится анализ существующих решений. В главах [-@sec:layout] и\ [-@sec:encoding]
представлены идеи и описания основных алгоритмов предложенного подхода: алгоритма 
совмещенной раскладки таблиц и алгоритма разностного кодирования таблиц. 
Для обоих алгоритмов приводятся доказательства верхней оценки качества сжатия
метаданных по сравнению со стандартной реализацией. В заключительной главе\ [-@sec:results] 
представлены результаты замеров суммарного размера таблиц на представительном 
наборе тестовых библиотек и приложений, а также представлено сравнение предложенного
подхода с существующими реализациями. -->

<!-- **Степень разработанности проблемы.** \todo{} -->

**Целью** данной работы является сокращение занимаемого 
места на диске приложением путем уменьшения суммарного размера крупнейшей 
структуры служебных метаданных управляемой среды --- таблиц виртуальных и 
интерфейсных методов. Для достижения данной цели были поставлены и решены следующие 
**задачи**:

1. Проанализировать существующие подходы к уменьшению размера таблиц виртуальных
и интерфейсных методов.

1. Выявить основные источники избыточности в структуре таблиц.

1. Разработать подход к генерации таблиц, минимизирующий суммарный размер таблиц 
в исполняемом файле.

<!-- **Методы исследования.** \todo{} -->

**Научная новизна и результаты, выносимые на защиту:**

1. Доказано отсутствие верхней границы суммарного размера таблиц для существующего 
подхода раскладки в Marmot, по сравнению с базовой версией раскладки. Показано 
существование иерархии для сколь угодно большого числа\ $\delta$, на которой 
суммарный размер таблиц раскладки Marmot в\ $\delta$ раз больше размера таблиц базовой раскладки.

1. Разработан алгоритм совмещенной раскладки таблиц виртуальных и интерфейсных 
методов, включающий только непересекающиеся таблицы суперинтерфейсов в таблицу
интерфейса-наследника. В отличие от существующих подходов, включающих абсолютно 
все таблицы суперинтерфейсов, для предложенного алгоритма доказана гарантированная
верхняя оценка суммарного размера таблиц, не превышающая размера таблиц базовой 
раскладки.

1. Разработан алгоритм разностного кодирования таблиц виртуальных и интерфейсных
методов в исполняемом файле с гарантированной верхней оценкой размера полученного
закодированного представления и линейной временной сложностью восстановления
исходной структуры таблиц.

**Теоретическая значимость работы:**

1. Доказана неограниченность размера таблиц при использовании раскладки Marmot, 
по сравнению с базовой раскладкой таблиц.

1. Доказано, что суммарный размер таблиц при использовании совмещенной раскладки 
не превосходит размера таблиц базовой раскладки.

1. Доказано, что размер закодированного представления таблиц с помощью разностного 
кодирования не превосходит исходного размера кодируемых данных при реалистичных 
ограничениях на количество типов и методов в программе.

**Практическая значимость работы:**

1. Разработанный алгоритм совмещенной раскладки таблиц
позволяет добиться значительного уменьшения дублирования данных в таблицах,
а также существенно уменьшить размер исполняемого файла на диске.

1. За счет того, что алгоритм совмещенной раскладки таблиц, как и реализация в Marmot, 
модифицирует только раскладку, данный подход не влияет на эффективность поиска таблицы 
для интерфейсного вызова и может применяться совместно с более эффективными 
методами поиска таблицы.

1. Разработанный алгоритм разностного кодирования позволяет значительно уменьшить
размер исполняемого файла, и при этом, эффективно восстановить исходную структуру
таблиц виртуальных и интерфейсных методов во время исполнения.

1. Предложенный метод разностного кодирования не зависит от деталей раскладки
таблиц, и поэтому может применяться совместно с любым алгоритмом раскладки.

**Апробация и реализация результатов исследования.** Основные результаты работы
докладывались и обсуждались на

- 56-й международной научной студенческой конференции "МНСК-2018" (Новосибирск, 2018);
- 58-й международной научной студенческой конференции "МНСК-2020" (Новосибирск, 2020);
- международной конференции "Иванниковские чтения" (Орел, 2020);
- семинарах кафедры программирования Новосибирского государственного университета в 2016-2020 годах.

Предложенные методы были применены в промышленной реализации языка Java 
"Excelsior JET Embedded 11.3 for Linux/ARM", а также в экспериментальной сборке 
Huawei JDK с поддержкой статической компиляции.

<!-- **Основные публикации по теме диссертации:**

**Статьи:**

1. Trepakov I., Pavlov P. Compact Interface Method Table Layout // 2020 Ivannikov
Memorial Workshop (IVMEM). IEEE, 2020. Сс. 62--68.

**Свидетельства о государственной регистрации программы для ЭВМ:**

2. Свидетельство о государственной регистрации программы для ЭВМ №2017613872. 
Excelsior JET Embedded 11.3 for Linux/ARM\ / А.Л.\ Гигуз и др. -- Заявка №2016663925. 
Дата регистрации 19 декабря 2016 г. Дата публикации 3 апреля 2017 г.

**Патентные заявки:**

3. Заявка PCT/RU2020/000406. Application Service Metadata Encoding and 
Initialization\ / И.С.\ Трепаков, П.Е.\ Павлов; заявитель Huawei Technologies Co., Ltd.;
заявл. 03.08.2020.

**Тезисы докладов:**

4. Трепаков И.С. Эффективная реализация таблиц виртуальных методов в языках с 
поддержкой ограниченного множественного наследования // Материалы\ 56\-й
Международной научной студенческой конференции МНСК-2018: Математика. 2018. С.\ 183.

5. Трепаков И.С. Эффективная генерация служебных метаданных для таблиц
виртуальных методов в статических компиляторах // Материалы\ 58\-й Международной 
научной студенческой конференции МНСК-2020: Математика. 2020. С.\ 133. -->

\pagebreak
# Предметная область {#sec:background}

<!-- ## Метаданные в управляемой среде

Любому языку программирования требуется поддержка во время исполнения, которую
осуществляет среда исполнения. Для низкоуровневых языков программирования эта 
среда может быть минимальна, предоставляя всего лишь легковесный интерфейс к
функционалу операционной системы. Но с повышением уровня абстракции языка,
возрастают и требования к среде исполнения. Абстракция модели памяти, обработка
исключений, динамическая диспетчеризация вызовов, автоматическое управление 
памятью -- поддержка всех этих динамических возможностей возлагается на среду 
исполнения языка, которую в таком случае называют *управляемой средой исполнения* 
(англ. *managed runtime environment*).

\todo{managed environment comments?}

Однако эффективная реализация поддержки времени исполнения требует кооперации
между компилятором и средой исполнения. Для этого, помимо кода и данных программы, 
компилятор порождает дополнительную информацию о программе, называемую 
*метаданными*.

### Классификация метаданных

Все метаданные управляемой среды можно разделить на две категории: *семантические
метаданные*, которые отражают семантические свойства исходной программы,
и *служебные метаданные*, которые необходимы для эффективного исполнения кода
программы.

В семантическую часть входят названия программных сущностей, таких как типы, поля и
функции, а также отношения между этими сущностями. Так, например, семантические метаданные 
объектно-ориентированной программы содержат, помимо имен классов, еще и отношения 
наследования между ними. Также к семантическим метаданным можно отнести номера
строк в исходном коде программы, которые могут использоваться при трассировке
стека вызовов.

Служебная часть метаданных состоит в из структур и данных, которые необходимы 
управляемой среде для эффективной поддержки перечисленных выше динамических 
возможностей языка. Например, сюда входят карты стека и регистров [@diwan1992compiler], 
окно Коэна [@cohen1991type] и таблица виртуальных методов [@ellis1990annotated; @driesen1996direct].

Отличительной чертой семантических метаданных является наличие их в явном виде в
исходном коде программы. Поэтому они остаются практически неизменными в 
процессе компиляции и во время исполнения программы с точностью до различий 
в кодировании. Служебные метаданные же, наоборот, не содержатся явно в исходном 
коде и всегда вычисляются либо в процессе компиляции, либо динамически во время 
исполнения программы. Однако служебные структуры могут сами содержать какую-то
семантическую информацию [^line-number-table-example], что может несколько 
затруднить определение точной категории для таких метаданных.

[^line-number-table-example]: Для примера можно рассмотреть таблицу номеров строк 
(*LineNumberTable*), порождаемую компилятором Java [@lindholm2014java], 
которая сопоставляет каждой строке исходного кода соответствующий диапазон
инструкций байткода. Сама таблица является служебной структурой, но номера строк
исходного кода являются семантическими метаданными. -->

<!-- ### Генерация метаданных -->

<!-- \todo{генерация семантических метаданных} -->

<!-- #### Статическая генерация -->

<!-- #### Динамическая генерация -->

<!-- \todo{далее только служебные метаданные} -->

<!-- ## Динамическая диспетчеризация

Одним из основных средств обеспечения полиморфизма в объектно-ориентированных 
языках программирования является *динамическая диспетчеризация* 
(англ. *dynamic dispatch*) --- механизм, позволяющий динамически определять 
реализацию вызываемого полиморфного метода на основе фактического типа объекта во 
время исполнения. Вызываемая реализация определяется в соответствии с семантикой
конкретного языка, с помощью некоторой процедуры
$$
resolve: (type, method) \to address,
$$
\noindent которая возвращает адрес искомой реализации по данному фактическому
типу объекта и вызываемому методу.

В качестве примера рассмотрим иерархию классов, изображенную на 
[@fig:class-hierarchy], которую также можно записать следующим образом в упрощенном
синтаксисе Java [@gosling2000java]:

```{.java}
class A           { m() {...} }
class B extends A { }
class C extends A { m() {...} }
```


\begin{tikzfigure}{fig:class-hierarchy}{Пример иерархии классов}{}

    \matrix [row sep=1.5em, column sep=1.5em] {
    \node [class] (A) {A}; & \\
    \node [class] (B) {B}; & \node [class] (C) {C}; \\
    };
    \graph [use existing nodes] {
        {B, C} -> A
    };

\end{tikzfigure}


Данная иерархия состоит из базового класса\ $A$ и двух наследников $B$ и\ $C$.
В классе\ $A$ объявлен виртуальный метод\ $m_A$, который переопределен в 
наследнике\ $C$ другой реализацией\ $m_C$. Вызов этого метода от переменной\ $x$
с *формальным* типом\ $A$ записывается следующим образом:

```{.java}
A x = ...
x.m()
```

Динамическая диспетчеризация этого виртуального вызова приведет к передаче 
управления в метод\ $m_C$, если в переменной\ $x$ во время исполнения окажется 
объект класса\ $C$, либо в метод\ $m_A$, если в переменной окажется объект 
класса\ $A$ или класса\ $B$. То же самое можно записать следующим образом,
используя процедуру $resolve$:
\begin{align*}
resolve(C,m) &= m_C, \\
resolve(B,m) &= m_A.
\end{align*}

Стоит отметить, что диспетчеризация подобного 
вызова может быть произведена статически, если компилятор смог доказать его
мономорфность (единственность вызываемой реализации), например с помощью анализа
иерархии классов (англ. *class hierarchy analysis*) [@dean1995optimization]. 
Такую статическую диспетчеризацию виртуального вызова называют *девиртуализацией* 
(англ. *devirtualization*) [@ishizaki2000study]. -->

<!-- ## Интерфейсное наследование -->

Среди современных объектно-ориентированных языков программирования большую популярность получила
концепция интерфейсного наследования, в которой все типы в программе делятся 
на два вида: *классы*, которые наследуются одиночно, и *интерфейсы*, 
которые наследуются множественно.
При этом каждый класс может наследовать (*реализовывать*) произвольное количество
интерфейсов, а интерфейсы не имеют состояния, то есть в них нельзя объявлять поля
и от них нельзя создавать объекты. Все полиморфные вызовы в таких языках разделяются 
на два вида: *виртуальные*, если формальный тип объекта вызова является классом, 
и *интерфейсные*, если формальный тип --- интерфейс. Пример иерархии с интерфейсным наследованием
может быть записан следующим образом:

```{.java}
interface K                    { c() }
interface J                    { b() }
interface I extends J, K       { c() }
class B implements J           { a() }
class C extends B implements I { b() }
```

Данная иерархия будет использоваться во всех поясняющих примерах далее, если не 
сказано обратного.

<!-- \begin{tikzfigure}{fig:hierarchy}{Пример иерархии с интерфейсным наследованием}{}

    \matrix [row sep=1.5em, column sep=1.5em] {
    \node [class] (B) {B}; & \node [interface] (J) {J}; & \node [interface] (K) {K}; \\
    \node [class] (C) {C}; & \node [interface] (I) {I}; & \\
    };
    \graph [use existing nodes] {
        C -> {B -> J, I -> {J, K}}
    };

\end{tikzfigure} -->

<!-- Интерфейсное наследование позволяет значительно упростить реализацию языка
по сравнению с полноценным множественным наследованием и в частности, реализацию 
динамической диспетчеризации. --> 

<!-- Для дальнейшего описания доказательств и алгоритмов полезно ввести следующие 
обозначения:

- $\mathbb{I}$ --- множество всех интерфейсов в программе;
- $\mathbb{C}$ --- множество всех классов в программе;
- $\mathbb{T} = \mathbb{I} \cup \mathbb{C}$ --- множество всех типов в программе;
- для произвольного типа\ $T \in \mathbb{T}$:
  - $\mathbb{I}_T$ --- множество всех суперинтерфейсов типа\ $T$;
  - $\mathbb{C}_T$ --- множество всех суперклассов типа\ $T$;
  - $\mathbb{S}_T = \mathbb{I}_T \cup \mathbb{C}_T$ --- множество всех предков типа\ $T$;
  - $\mathbb{M}_T$ --- множество методов, объявленных в типе\ $T$ и в его предках;
- $super_C$ --- непосредственный суперкласс класса\ $C \in \mathbb{C}$, если
  $\mathbb{C}_S \neq \varnothing$, иначе выделенное значение $null$. -->


## Таблица виртуальных методов

В случае одиночного наследования классов, виртуальный вызов можно реализовать 
наиболее эффективно с помощью специальной структуры *таблицы виртуальных
методов* (англ. *virtual method table*, *VMT*, *vtable*), которая применяется
практически во всех исследовательских и промышленных реализациях языков, 
поддерживающих одиночное наследование. Таблица виртуальных методов для некоторого 
класса\ $C$ представляет собой 
массив\ $vmt_C$ адресов реализаций методов, доступный напрямую из любого объекта 
этого класса. Каждому методу\ $m$ класса\ $C$ назначается
*виртуальный номер*\ $vnum_{C,m}$, соответствующий индексу ячейки таблицы\ $vmt_C$, 
в которой находится адрес реализации этого метода. При переопределении метода
в наследнике, новая реализация получает такой же виртуальный номер, 
что и оригинальный метод. Фактически это означает, что раскладка VMT 
класса должна *расширять* раскладку VMT суперкласса.

\begin{tikzfigure}{fig:vmt-example}{Таблица виртуальных методов класса~$C$}{}

    \begin{struct}{object}
        \header             {object header} {Object}
        \field [dotted]  {} {object vmt}    {\&VMT\textsubscript{C}}
        \field           {} {object rest}   {...}
    \end{struct}


    \begin{struct}[right={2*\structnodewidth} of object]{vmt C}
        \header                {vmt C header} {VMT\textsubscript{C}}
        \field [dotted]  {[0]} {vmt C 0}      {\&B::a()}
        \field [dashed]  {[1]} {vmt C 1}      {\&C::b()}
        \field           {[2]} {vmt C 2}      {\&I::c()}
    \end{struct}


    \begin{struct}[right={2.5*\structnodewidth} of vmt C]{vmt B}
        \header                {vmt B header} {VMT\textsubscript{B}}
        \field [dotted]  {[0]} {vmt B 0}      {\&B::a()}
        \field           {[1]} {vmt B 1}      {\&J::b()}
    \end{struct}

    \connect{object vmt}{vmt C header}{}

    \begin{scope}[on background layer]
        \draw [dashed] (vmt C 0.north east) -- (vmt B 0.north west);
        \draw [dashed] (vmt C 1.south east) -- (vmt B 1.south west);
    \end{scope}

\end{tikzfigure}

Таким образом по виртуальному номеру\ $vnum_{C,m}$ 
всегда можно получить актуальную реализацию метода\ $m$ не только в таблице самого
класса\ $C$, но и в таблице любого его наследника. Данное свойство позволяет
генерировать виртуальный вызов `x.m()` как обычный косвенный вызов по таблице, 
полученной напрямую из объекта:

```
call x.vmt[vnum$\textsubscript{C,m}$]
```

<!-- ### Раскладка -->

<!-- Более формально, под *раскладкой* таблицы\ $vmt_C$ класса\ $C$ будем понимать 
пару\ $(size_C,vnum_{C,\ast})$, состоящую из размера этой таблицы и отображения 
виртуальных номеров методов класса\ $C$. Далее приводится один из возможных 
алгоритмов раскладки VMT.

\Begin{algorithm}{alg:base-vmt-layout} Построение раскладки VMT класса\ $C$.

1. Если класс C имеет суперкласс, то скопировать начальную раскладку из него.
1. Добавить новые виртуальные методы в раскладку.

\End{algorithm} -->

<!-- \Begin{algorithm}{alg:base-vmt-layout} Построение раскладки VMT класса\ $C$.
```
def buildVMTLayout(C):
  size$\textsubscript{C\ \ }$ := 0
  vnum$\textsubscript{C,\ast}$ := {}

  // 1. Если класс C имеет суперкласс, то скопировать начальную раскладку из него.
  with B := super$\textsubscript{C}$:
    size$\textsubscript{C\ \ }$ := size$\textsubscript{B}$
    vnum$\textsubscript{C,m}$ := vnum$\textsubscript{B,m}$ for m <- $\(\mathbb{M}\)\textsubscript{B}$
  
  // 2. Добавить новые виртуальные методы в раскладку.
  for m <- $\(\mathbb{M}\)\textsubscript{C}$ if undefined vnum$\textsubscript{C,m}$:
    vnum$\textsubscript{C,m}$ := size$\textsubscript{C}$
    size$\textsubscript{C\ \ }$ := size$\textsubscript{C}$ + 1
```
\End{algorithm}

Имея такую раскладку, сама таблица виртуальных методов строится довольно прямолинейно 
по алгоритму\ \ref{alg:base-vmt-build}.

\Begin{algorithm}{alg:base-vmt-build} Построение VMT класса\ $C$.
```
def buildVMT(C):
  // 1. Выделить массив адресов размера size$\textsubscript{C}$.
  vmt$\textsubscript{C}$ := array size$\textsubscript{C}$ of address

  // 2. Заполнить ячейки виртуальных методов.
  for m <- $\(\mathbb{M}\)\textsubscript{C}$:
    vmt$\textsubscript{C}$[vnum$\textsubscript{C,m}$] := resolve(C,m)
```
\End{algorithm} -->

<!-- ### Множественное наследование -->

<!-- Впервые использование таблицы виртуальных методов было предложено в языке 
Simula [@dahl1973simula], поддерживающего только одиночное наследование классов. 
Но в последствии таблица была адаптирована и для случая множественного 
наследования при разработке языка C++ [@ellis1990annotated], что потребовало 
значительного усложения структуры таблиц, а также дополнительных издержек 
на вызовы [@stroustrup1989multiple]. -->

<!-- \todo{Реализация для множественного наследования (подробности)} -->

## Таблица интерфейсных методов

Ограничения, накладываемые на интерфейсы, позволяют избежать типичных трудностей, 
сопровождающих поддержку множественного наследования [@stroustrup1989multiple] и 
использовать для реализации интерфейсных вызовов структуру *таблиц интерфейсных методов* 
(англ. *interface method table*, *IMT*, *itable*).
Таблица интерфейсных методов (или *интерфейсная таблица*) для класса\ $C$ и суперинтерфейса\ $I$ 
представляет собой массив\ $imt_{C,I}$ адресов реализаций в классе\ $C$ методов
интерфейса\ $I$. По аналогии с таблицей виртуальных методов, каждому методу\ $m$
интерфейса\ $I$ назначается *виртуальный номер*\ $vnum_{I,m}$, соответствующий 
индексу ячейки таблицы\ $imt_{X,I}$, в которой находится адрес реализации этого 
метода в каждом классе\ $X$, который реализует данный интерфейс. Это позволяет
сгенерировать интерфейсный вызов таким же образом, как виртуальный --- с помощью 
косвенного вызова по интерфейсной таблице. Однако из-за того, что класс может 
наследовать произвольное количество интерфейсов, адрес IMT для вызова 
не всегда может быть известен во время компиляции. Поэтому
в общем случае интерфейсный вызов требует динамического определения таблицы во
время исполнения, например, с помощью линейного поиска IMT среди реализуемых
классом интерфейсов.


\begin{tikzfigure}{fig:imt-example}{Таблицы виртуальных и интерфейсных методов класса~$C$}{}

    \begin{struct}{object}
        \header             {object header} {Object}
        \field [dotted]  {} {object vmt}    {\&VMT\textsubscript{C}}
        \field [dotted]  {} {object imts}   {\&IMTs}
        \field           {} {object rest}   {...}
    \end{struct}


    \begin{struct}[right={2*\structnodewidth} of object]{vmt C}
        \header                {vmt C header} {VMT\textsubscript{C}}
        \field [dotted]  {[0]} {vmt C 0}      {\&B::a()}
        \field [dashed]  {[1]} {vmt C 1}      {\&C::b()}
        \field           {[2]} {vmt C 2}      {\&I::c()}
    \end{struct}

    \connect{object vmt}{vmt C header}{}


    \begin{struct}[right={2.5*\structnodewidth} of vmt C]{vmt B}
        \header                {vmt B header} {VMT\textsubscript{B}}
        \field [dotted]  {[0]} {vmt B 0}      {\&B::a()}
        \field           {[1]} {vmt B 1}      {\&J::b()}
    \end{struct}


    \begin{struct}[below=\structnodeheight of object rest]{imts}
        \header              {imts header} {IMTs}
        \field [dotted]  {I} {imts I}      {\&IMT\textsubscript{C,I}}
        \field [dotted]  {J} {imts J}      {\&IMT\textsubscript{C,J}}
        \field           {K} {imts K}      {\&IMT\textsubscript{C,K}}
    \end{struct}

    \draw [->] (object imts.west) 
            -| ($ (imts header.west) - (1,0) $)
            -- (imts header.west);



    \begin{struct}[below=\structnodeheight of vmt C 2]{imt C}
        \field [dotted]  {[0]} {imt C I 0}    {\&C::b()}
        \field [draw]    {[1]} {imt C I 1}    {\&I::c()}
        \field [draw]    {[0]} {imt C J 0}    {\&C::b()}
        \field           {[0]} {imt C K 0}    {\&I::c()}
    \end{struct}

    \imtR{imt C I 0}{imt C I 1}{IMT\textsubscript{C,I}}
    \imtR{imt C J 0}{imt C J 0}{IMT\textsubscript{C,J}}
    \imtR{imt C K 0}{imt C K 0}{IMT\textsubscript{C,K}}

    \begin{struct}[right={2.5*\structnodewidth} of imt C J 0.north]{imt B}
        \field           {[0]} {imt B J 0}    {\&J::b()}
    \end{struct}

    \imtR{imt B J 0}{imt B J 0}{IMT\textsubscript{B,J}}

    \begin{scope}[on background layer]
        \connect{imts I.east}{imt C I 0.west}{}
        \connect{imts J.east}{imt C J 0.west}{}
        \connect{imts K.east}{imt C K 0.west}{}

        \draw [dashed] (vmt C 0.north east) -- (vmt B 0.north west);
        \draw [dashed] (vmt C 1.south east) -- (vmt B 1.south west);
        \draw [dashed] (imt C J 0.north east) -- (imt B J 0.north west);
        \draw [dashed] (imt C J 0.south east) -- (imt B J 0.south west);
    \end{scope}

\end{tikzfigure}

Таким образом, сгенерированный код для интерфейсного метода `x.m()` состоит
из некоторой процедуры поиска и косвенного вызова по полученной таблице, аналогично
виртуальному вызову:

```
imt$\textsubscript{C,I}$ := x.imts.find(&I)
call imt$\textsubscript{C,I}$[vnum$\textsubscript{I,m}$] 
```

<!-- ### Раскладка -->

<!-- По аналогии с таблицей виртуальных методов, можно формально определить *раскладку*
интерфейсной таблицы\ $imt_{C,I}$ как пару\ $(size_I,vnum_{I,\ast})$, состоящую
из размера этой таблицы и отображения виртуальных методов интерфейса\ $I$. Заметим,
что такая раскладка не зависит от класса, реализующего интерфейс, что вполне
соответствуют данному выше определению виртуальных номеров. Так как никакого 
наследования раскладки между интерфейсами нет, алгоритм\ \ref{alg:base-imt-layout} 
построения раскладки IMT выглядит тривиально.

\Begin{algorithm}{alg:base-imt-layout} Построение раскладки IMT интерфейса\ $I$.

1. Добавить все интерфейсные методы в раскладку.

\End{algorithm} -->

<!-- \Begin{algorithm}{alg:base-imt-layout} Построение раскладки IMT интерфейса\ $I$.
```
def buildIMTLayout(I):
  size$\textsubscript{I\ \ }$ := 0
  vnum$\textsubscript{I,\ast}$ := {}

  // 1. Добавить все интерфейсные методы в раскладку.
  for m <- $\(\mathbb{M}\)\textsubscript{I}$:
    vnum$\textsubscript{I,m}$ := size$\textsubscript{I}$
    size$\textsubscript{I\ \ }$ := size$\textsubscript{I}$ + 1
```
\End{algorithm}

Далее представлен алгоритм построения самой IMT по полученной раскладке.

\Begin{algorithm}{alg:base-imt-build} Построение IMT класса\ $C$ и интерфейса\ $I$.
```
def buildIMT(C,I):
  // 1. Выделить массив адресов размера size$\textsubscript{I}$.
  imt$\textsubscript{C,I}$ := array size$\textsubscript{I}$ of address

  // 2. Заполнить ячейки интерфейсных методов.
  for m <- $\(\mathbb{M}\)\textsubscript{I}$:
    imt$\textsubscript{C,I}$[vnum$\textsubscript{I,m}$] := resolve(C,m)
```
\End{algorithm} -->

## Существующие подходы

Многие табличные реализации интерфейсных вызовов жертвуют размером структур
ради производительности самого вызова. Так, например, в проектах CACAO [@krall1997cacao],
SableVM [@gagnon2001sable] и Jikes RVM [@deutsch1984efficient] удалось полностью 
избавиться от поиска таблицы с помощью одной глобально индексируемой таблицы 
интерфейсных методов в каждом классе. Но некоторые подходы делают больший акцент
на уменьшении размера служебных данных и, в частности, таблиц интерфейсных методов.

Авторы системы Marmot [@fitzgerald2000marmot], разработанной в лаборатории 
Microsoft Research, предложили инновационный способ наследования раскладки таблиц,
при котором IMT каждого интерфейса включает в себя IMT всех своих непосредственных
суперинтерфейсов как подтаблицы. Такой подход позволяет в каждом классе создавать
только таблицы непосредственно реализуемых суперинтерфейсов, которые уже будут содержать
все необходимые IMT. Однако, как отмечают авторы, при такой раскладке может возникнуть
дублирование информации, которого не было в базовой раскладке. Несмотря на это, 
на практике, данный подход дает заметное уменьшение суммарного размера таблиц.

Независимо к похожей вложенной раскладке IMT пришли создатели платформы 
SHAP [@preusser2011increasing] --- аппаратного процессора Java байткода
для встраиваемых устройств. В отличие от классической структуры IMT, в SHAP все таблицы 
вкладываются напрямую в VMT, позволяя переиспользовать ячейки IMT под виртуальные вызовы.
Дополнительно каждая таблица (и подтаблица) имеет заголовок в виде ссылки
на тип соответствующего интерфейса, который позволяет искать необходимую интерфейсную
таблицу напрямую в VMT без отдельной структуры для поиска.

Также, авторам SHAP удалось во многом избавиться от необходимости линейного 
поиска при вызове за счет продвинутого статического анализа и специального 
механизма раскраски указателей [@preusser2007enabling],
в котором указатели на объекты помечаются отступом до IMT, 
соответствующей одному из суперинтерфейсов настоящего класса этого объекта. Этот 
отступ кодируется напрямую в указателе, и часто может быть статически вычислен
компилятором. Таким образом интерфейсный вызов превращается практически в
виртуальный, кроме тех случаев, когда компилятор не может статически гарантировать 
соответствие пометки указателя нужному интерфейсу. В такой ситуации вставляется 
проверка соответствия цвета, которая может быть реализована эффективно,
благодаря наличию ссылки на интерфейс в заголовке таблицы, с последующим поиском
таблицы, если проверка провалилась.

Однако, у такого подхода есть свои недостатки: любое кодирование информации в указателях
неизбежно приводит к усложнению управления памятью и отладки среды исполнения, 
а наличие заголовков у таблиц уменьшает эффект сжатия от вложенной раскладки таблиц.

## Источники избыточности
<!-- ## Основная задача -->
<!-- ## Задача минимизации размера таблиц -->

<!-- Большинство представленных выше модификаций интерфейсных таблиц (за исключением
Marmot [@fitzgerald2000marmot] и SHAP [@preusser2011increasing]) решали в первую 
очередь проблему производительности интерфейсных вызовов, и только потом 
переходили к решению проблемы размера таблиц. Однако, уменьшение суммарного размера
метаданных может оказаться одной из важнейших задач в проекте, если целевая платформа
значительно ограничена в ресурсах памяти и дискового пространства, как, например,
встраиваемые устройства. Учитывая, что таблицы виртуальных и интерфейсных методов
являются самыми крупными структурами служебных метаданных в типичной программе,
целенаправленное уменьшение их суммарного размера способно дать значительное уменьшение
как потребления памяти, так и размера исполняемого файла на диске. -->

Основной причиной большого размера таблиц является избыточность данных в них.
В идеальной табличной структуре для диспетчеризации вызовов находилось бы ровно
по одному адресу для каждой уникальной реализации метода. Но уже в таблицах 
виртуальных методов при одиночном наследовании возникает дублирование данных между
таблицами класса и суперкласса, а при добавлении интерфейсных таблиц его становится
еще больше. Для примера рассмотрим структуру таблиц, изображенную на [@fig:imt-example]. 
Несмотря на то, что всего уникальных реализаций методов только четыре: `&B::a()`,
`&J::b()`, `&C::b()` и `&I::c()`; каждая из них встречается в таблицах минимум
два раза. Отсюда выделяются два вида избыточности таблиц:

- *межклассовая избыточность*, возникающая при наследовании реализаций, определенных 
  в суперклассе или суперинтерфейсе, и
- *внутриклассовая избыточность*, возникающая при множественном наследовании
  интерфейсов.

<!-- \begin{tikzfigure}{fig:duplication-example}{Таблицы виртуальных и интерфейсных методов классов $B$ и~$C$}{}

    \begin{struct}{vmt B}
        \header                 {vmt B header} {VMT\textsubscript{B}}
        \field [dotted]      {} {vmt B 0}      {\&B::a()}
        \field               {} {vmt B 1}      {\&J::b()}
    \end{struct}


    \begin{struct}[right={2*\structnodewidth} of vmt B]{vmt C}
        \header                 {vmt C header} {VMT\textsubscript{C}}
        \field [dotted]      {} {vmt C 0}      {\&B::a()}
        \field [dashed]      {} {vmt C 1}      {\&C::b()}
        \field               {} {vmt C 2}      {\&I::c()}
    \end{struct}

    \begin{struct}[below=\structnodeheight of vmt C 2]{imt C}
        \field [dotted]  {} {imt C I 0}    {\&C::b()}
        \field [draw]    {} {imt C I 1}    {\&I::c()}
        \field [draw]    {} {imt C J 0}    {\&C::b()}
        \field           {} {imt C K 0}    {\&I::c()}
    \end{struct}


    \imtR{imt C I 0}{imt C I 1}{IMT\textsubscript{C,I}}
    \imtR{imt C J 0}{imt C J 0}{IMT\textsubscript{C,J}}
    \imtR{imt C K 0}{imt C K 0}{IMT\textsubscript{C,K}}

    \begin{struct}[left={2*\structnodewidth} of imt C J 0.north]{imt B}
        \field           {} {imt B J 0}    {\&J::b()}
    \end{struct}

    \imtL{imt B J 0}{imt B J 0}{IMT\textsubscript{J,B}}


    \begin{scope}[on background layer]
        \draw [dashed] (vmt B 0.north east) -- (vmt C 0.north west);
        \draw [dashed] (vmt B 1.south east) -- (vmt C 1.south west);
        \draw [dashed] (imt B J 0.north east) -- (imt C J 0.north west);
        \draw [dashed] (imt B J 0.south east) -- (imt C J 0.south west);
    \end{scope}

\end{tikzfigure} -->

<!-- Можно выделить два вида избыточности таблиц: 

- *межклассовая избыточность*, возникающая при наследовании реализаций, определенных 
  в суперклассе или суперинтерфейсе, и
- *внутриклассовая избыточность*, возникающая при множественном наследовании
  интерфейсов. -->

<!-- Все существующие подходы уменьшали избыточность только в пределах одного класса.
При этом каждый из них мог потенциально наоборот, добавить дублирования, и 
увеличить размер таблиц по сравнению с базовой реализацией.
В данной работе предлагается два механизма, позволяющих адресовать каждый из видов 
избыточности для статически компилируемой программы, и гарантированно не увеличить
размер таблиц по сравнению с базовой реализацией:

- *совмещенная раскладка таблиц* для уменьшения внутриклассовой избыточности, и
- *разностное кодирование таблиц* для минимизации межклассовой избыточности 
  метаданных на диске. -->

\pagebreak
# Совмещенная раскладка таблиц {#sec:layout}

Для уменьшения внутриклассовой избыточности был разработан новый алгоритм 
совмещенной раскладки интерфейсных таблиц внутри VMT, основанный на тех же идеях, 
что и вложенная раскладка в SHAP и Marmot. На [@fig:combined-layout-steps] 
проиллюстрированы основные преобразования базовой раскладки, вошедшие в итоговую 
совмещенную раскладку таблиц:

1. По аналогии с раскладкой в SHAP интерфейсные таблицы становятся частью 
раскладки VMT и наследуются при расширении раскладки VMT суперкласса ([@fig:vmt-imt-layout]).
1. По аналогии с раскладкой в Marmot раскладка IMT включает таблицы суперинтерфейсов 
как подтаблицы ([@fig:imt-imt-layout]). Но в отличие от Marmot, в раскладку IMT 
добавляются только непересекающиеся по методам таблицы суперинтерфейсов.
Таким образом размер IMT остается таким же как в базовой раскладке.
1. В некоторых случаях, последняя IMT суперкласса может быть расширена с помощью 
одной из таблиц класса-наследника ([@fig:last-imt-layout]). Чтобы увеличить шансы
такого расширения, подтаблицы VMT сортируются в порядке возрастания размера, а
подтаблицы IMT сортируются в порядке убывания размера, позволяя наибольшей
IMT расширяться наибольшей IMT класса-наследника.

\begin{figure}
\tikzsubfloat{fig:base-vmt-layout}{Базовая раскладка}{


    \begin{struct}{vmt C}
        \header                 {vmt C header} {VMT\textsubscript{C}}
        \field [dotted]      {} {vmt C 0}      {\&B::a()}
        \field [dashed]      {} {vmt C 1}      {\&C::b()}
        \field [draw,thick]  {} {vmt C 2}      {\&I::c()}
        \field [dotted]      {} {imt C I 0}    {\&C::b()}
        \field [draw]        {} {imt C I 1}    {\&I::c()}
        \field [draw]        {} {imt C J 0}    {\&C::b()}
        \field               {} {imt C K 0}    {\&I::c()}
    \end{struct}


    \imtL{imt C I 0}{imt C I 1}{IMT\textsubscript{C,I}}
    \imtL{imt C J 0}{imt C J 0}{IMT\textsubscript{C,J}}
    \imtL{imt C K 0}{imt C K 0}{IMT\textsubscript{C,K}}

    \begin{struct}[right={2*\structnodewidth} of vmt C]{vmt B}
        \header                 {vmt B header} {VMT\textsubscript{B}}
        \field [dotted]      {} {vmt B 0}      {\&B::a()}
        \field [draw,thick]  {} {vmt B 1}      {\&J::b()}
        \field               {} {imt B J 0}    {\&J::b()}
    \end{struct}

    \imtR{imt B J 0}{imt B J 0}{IMT\textsubscript{B,J}}


    \begin{scope}[on background layer]
        \draw [dashed] (vmt C 0.north east) -- (vmt B 0.north west);
        \draw [dashed] (vmt C 1.south east) -- (vmt B 1.south west);
    \end{scope}

}
\tikzsubfloat{fig:vmt-imt-layout}{Совмещение VMT--IMT}{


    \begin{struct}{vmt C}
        \header                 {vmt C header} {VMT\textsubscript{C}}
        \field [dashed]      {} {vmt C 0}      {\&B::a()}
        \field [dashed]      {} {imt C J 0}    {\&C::b()}
        \field [dashed]      {} {imt C K 0}    {\&I::c()}
        \field [dotted]      {} {imt C I 0}    {\&C::b()}
        \field               {} {imt C I 1}    {\&I::c()}
    \end{struct}


    \imtL{imt C I 0}{imt C I 1}{IMT\textsubscript{C,I}}
    \imtR{imt C J 0}{imt C J 0}{IMT\textsubscript{C,J}}
    \imtL{imt C K 0}{imt C K 0}{IMT\textsubscript{C,K}}

    \begin{struct}[right={2*\structnodewidth} of vmt C]{vmt B}
        \header                 {vmt B header} {VMT\textsubscript{B}}
        \field [dashed]      {} {vmt B 0}      {\&B::a()}
        \field               {} {imt B J 0}    {\&J::b()}
    \end{struct}

    \imtR{imt B J 0}{imt B J 0}{IMT\textsubscript{B,J}}


    \begin{scope}[on background layer]
        \draw [dashed] (vmt C 0.north east)   -- (vmt B 0.north west);
        \draw [dashed] (imt C J 0.south east) -- (imt B J 0.south west);
    \end{scope}

}
\hfill
\tikzsubfloat{fig:imt-imt-layout}{Совмещение IMT--IMT}{


    \begin{struct}{vmt C}
        \header                 {vmt C header} {VMT\textsubscript{C}}
        \field [dashed]      {} {vmt C 0}      {\&B::a()}
        \field [dashed]      {} {imt C J 0}    {\&C::b()}
        \field [dashed]      {} {imt C I 0}    {\&C::b()}
        \field               {} {imt C K 0}    {\&I::c()}
    \end{struct}


    \imtL{imt C I 0}{imt C K 0}{IMT\textsubscript{C,I}}
    \imtR{imt C I 0}{imt C I 0}{IMT\textsubscript{C,J}}
    \imtR{imt C J 0}{imt C J 0}{IMT\textsubscript{C,J}}
    \imtR{imt C K 0}{imt C K 0}{IMT\textsubscript{C,K}}

    \begin{struct}[right={2*\structnodewidth} of vmt C]{vmt B}
        \header                 {vmt B header} {VMT\textsubscript{B}}
        \field [dashed]      {} {vmt B 0}      {\&B::a()}
        \field               {} {imt B J 0}    {\&J::b()}
    \end{struct}

    \imtR{imt B J 0}{imt B J 0}{IMT\textsubscript{B,J}}


    \begin{scope}[on background layer]
        \draw [dashed] (vmt C 0.north east)   -- (vmt B 0.north west);
        \draw [dashed] (imt C J 0.south east) -- (imt B J 0.south west);
    \end{scope}

}
\tikzsubfloat{fig:last-imt-layout}{Расширение последней IMT суперкласса}{


    \begin{struct}{vmt C}
        \header                 {vmt C header} {VMT\textsubscript{C}}
        \field [dashed]      {} {vmt C 0}      {\&B::a()}
        \field [dashed]      {} {imt C J 0}    {\&C::b()}
        \field               {} {imt C K 0}    {\&I::c()}
    \end{struct}


    \imtL{imt C J 0}{imt C K 0}{IMT\textsubscript{C,I}}
    \imtR{imt C J 0}{imt C J 0}{IMT\textsubscript{C,J}}
    \imtR{imt C K 0}{imt C K 0}{IMT\textsubscript{C,K}}

    \begin{struct}[right={2*\structnodewidth} of vmt C]{vmt B}
        \header                 {vmt B header} {VMT\textsubscript{B}}
        \field [dashed]      {} {vmt B 0}      {\&B::a()}
        \field               {} {imt B J 0}    {\&J::b()}
    \end{struct}

    \imtR{imt B J 0}{imt B J 0}{IMT\textsubscript{B,J}}


    \begin{scope}[on background layer]
        \draw [dashed] (vmt C 0.north east)   -- (vmt B 0.north west);
        \draw [dashed] (imt C J 0.south east) -- (imt B J 0.south west);
    \end{scope}

}
\caption{Этапы перехода к совмещенной раскладке таблиц}
\label{fig:combined-layout-steps}
\end{figure}

\begin{tikzfigure}{fig:marmot-hierarchy}{Иерархия~$H_{k,m,n}$}{}


    \matrix [row sep=1.5em, column sep=1.5em] {
    & \node [interface] (L k) {L$\textsubscript{k}$}; & & \\
    \node [interface] (I 1) {I\textsubscript{1}}; & 
      \node [interface] (I 2) {I\textsubscript{2}}; & 
      \node (I dots) {...}; &
      \node [interface] (I m) {I\textsubscript{m}}; \\
    \node [interface] (J 1) {J\textsubscript{1}}; & 
      \node [interface] (J 2) {J\textsubscript{2}}; & 
      \node (J dots) {...}; &
      \node [interface] (J n) {J\textsubscript{n}}; \\
    & \node [class] (C) {C}; & & \\
    };
    \graph [use existing nodes] {
        C -> {
          J 1 -> {I 1, I 2, I m}, 
          J 2 -> {I 1, I 2, I m}, 
          J n -> {I 1, I 2, I m}
        },
        {I 1, I 2, I m} -> L k
    };

\end{tikzfigure}

Размер таблиц при использовании полученной совмещенной раскладки гарантированно
не превосходит размера таблиц базовой раскладки, что подтверждается следующей
теоремой\ \ref{stmt:combined-layout-size}.

\Begin{theorem}\label{stmt:combined-layout-size} Для произвольной иерархии\ $H$
суммарный размер таблиц в совмещенной раскладке не превосходит размера таблиц
в базовой раскладке:
$$
\forall H : size^{\text{\it Combined}}_H \leq size^{\text{\it Base}}_H.
$$
\End{theorem}

\Begin{proof} Каждое из рассмотренных преобразований не увеличивает суммарный размер
таблиц. ^[Подробное доказательство представлено в тексте диссертации.]
\End{proof}


Однако, для раскладки Marmot, в которой в IMT включаются все таблицы суперинтерфейсов,
подобных гарантий нет. Более того размер таблиц в этой раскладке может неограниченно
превышать размер таблиц базовой раскладки, о чем говорит следующая 
теорема\ \ref{stmt:marmot-layout-size}.

\Begin{theorem}\label{stmt:marmot-layout-size} Для произвольной константы\ $\delta > 1$ 
существует иерархия\ $H$, в которой суммарный размер таблиц раскладки Marmot
больше суммарного размера таблиц базовой раскладки в\ $\delta$ раз:
$$
\forall \delta > 1\ \exists H : size^{\text{\it Marmot}}_H 
  \geq \delta size^{\text{\it Base}}_H.
$$ {#eq:marmot-layout-size}
\End{theorem}

\Begin{proof} Рассмотрим следующую иерархию $H_{k,m,n}$, изображенную 
на [@fig:marmot-hierarchy]:
```{.java}
interface L$\textsubscript{k}$$\textsubscript{\ }$$\textsubscript{\ }$                   { x$\textsubscript{1}$(); ...; x$\textsubscript{k}$() }
interface I$\textsubscript{1}$ extends L$\textsubscript{k}$$\textsubscript{\ }$         { y$\textsubscript{1}$() }
...
interface I$\textsubscript{m}$ extends L$\textsubscript{k}$$\textsubscript{\ }$         { y$\textsubscript{m}$() }
interface J$\textsubscript{1}$ extends I$\textsubscript{1}$, ..., I$\textsubscript{m}$ { z$\textsubscript{1}$() }
...
interface J$\textsubscript{n}$ extends I$\textsubscript{1}$, ..., I$\textsubscript{m}$ { z$\textsubscript{n}$() }
class C$\textsubscript{\ }$  implements J$\textsubscript{1}$, ..., J$\textsubscript{n}$ {$\textsubscript{\ }$     }
```

VMT класса\ $C$ в обеих раскладках будет состоять из всех объявленных в иерархии
методов, поэтому ее размер будет равен:
$$
|vmt_C| = |x_1...x_k y_1...y_m z_1...z_n| = k + m + n.
$$

\clearpage
Размеры интерфейсных таблиц и суммарный размер таблиц вычисляются следующим образом:

\begin{figure}[hbt!]
\begin{minipage}[t]{0.5\textwidth}
\centering
\textbf{Base}
$$
\begin{aligned}
|imt_{C,L}| &= |x_1...x_k| = k \\
|imt_{C,I_i}| &= |x_1...x_k y_i| = k + 1 \\
|imt_{C,J_j}| &= |x_1...x_k y_1...y_m z_j| \\
  &= k + m + 1 \\ \\
size^{\text{\it Base}}_H &= |vmt_C| + |imt_{C,L}| \\
  &+ \sum\limits_{i = 1,...,m}|imt_{C,I_i}| \\
  &+ \sum\limits_{j = 1,...,n}|imt_{C,J_j}| \\
  &= (k + m + n) + k + m(k + 1) \\
  &+ n(k + m + 1)
\end{aligned}
$$
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
\centering
\textbf{Marmot}
$$
\begin{aligned}
|imt_{C,L}| &= |x_1...x_k| = k \\
|imt_{C,I_i}| &= |imt_{C,L}y_i| = k + 1 \\
|imt_{C,J_j}| &= |imt_{C,I_1}...imt_{C,I_m} z_j| \\
  &= m(k + 1) + 1 \\ \\
size^{\text{\it Marmot}}_H &= |vmt_C| \\
  &+ \sum\limits_{j = 1,...,n}|imt_{C,J_j}| \\
  &= (k + m + n) \\
  &+ n(m(k + 1) + 1)
\end{aligned}
$$
\end{minipage}
\end{figure}

Тогда, для выполнения неравенства (\ref{eq:marmot-layout-size}) 
достаточно выбрать целые значения $k$, $m$ и\ $n$ удовлетворяющие следующей системе
неравенств: ^[Подробное доказательство представлено в тексте диссертации.]
$$
\begin{cases}
m > \delta \\
k > \frac{
  (m + 2)(\delta - 1)
}{
  m - \delta
} \\
n \geq \frac{
  (k + m)(2\delta - 1) + \delta k m
}{
  k(m - \delta) - (m + 2)(\delta - 1)
}
\end{cases}.
$$ {#eq:marmot-kmn}

Например, при $\delta = 2$ неравенство (\ref{eq:marmot-layout-size}) выполняется
для иерархии $H_{6,3,63}$.

\End{proof}

\pagebreak
# Разностное кодирование таблиц {#sec:encoding}

Для уменьшения межклассовой избыточности был разработан алгоритм разностного 
кодирования таблиц, при котором в исполняемый файл записывается компактное
представление разницы таблиц класса и его суперкласса, а затем восстанавливается
во время исполнения в полноценную структуру таблиц виртуальных и интерфейсных методов.
Закодированная разность таблиц представляет собой последовательность инструкций
$Put_1(mid)$, $Put_2(cid,mid)$ и $Skip(k)$, описанных в таблице\ [-@tbl:encoding-instructions].

+------------+-----+----------------------------------------------------------------+
| Инструкция | Код | Интерпретация                                                  |
+:===========+====:+:===============================================================+
| $Put_1     | 0x0 | Положить значение текущей ячейки VMT равным адресу             |
| (mid)$     |     | метода\ $mid$ в данном классе и перейти к следующей ячейке.    |
+------------+-----+----------------------------------------------------------------+
| $Put_2     | 0x1 | Положить значение текущей ячейки VMT равным адресу             |
| (tid,mid)$ |     | метода\ $mid$ в супертипе\ $tid$ и перейти к следующей ячейке. |
+------------+-----+----------------------------------------------------------------+
| $Skip(k)$  | 0x2 | Пропустить следующие $k$ ячеек.                                |
+------------+-----+----------------------------------------------------------------+

: Инструкции разностного кодирования {#tbl:encoding-instructions}

Каждая инструкция представляется в виде одного или двух (в зависимости от 
количества аргументов) целых 32-битных чисел. При этом *Код* инструкции 
закодирован вместе с первым аргументом: `\texttt{(Kод | Арг$\textsubscript{0}$ <{}< 1) [, Арг$\textsubscript{0}$]}`{=latex}. Полученная
последовательность целых чисел дополнительно кодируется в формате 
Unsigned LEB128\ [@uleb2021online]. В предположении, что IMT включаются как 
подтаблицы в VMT, порождение инструкций кодирования и восстановление VMT 
класса\ $C$ описаны далее в алгоритмах \ref{alg:encoding} и\ \ref{alg:decoding}.

\Begin{algorithm}{alg:encoding} Кодирование\ $vmt_C$.

#. Инициализировать $cur \gets 0$, $k \gets 0$;
#. Пока $cur < |vmt_C|$:
    #. Если у класса\ $C$ нет суперкласса или реализации по индексу $cur$ отличаются 
    между $vmt_C$ и VMT суперкласса, то:
        #. Если $k > 0$, то породить инструкцию $Skip(k)$ и задать $k \gets 0$;
        #. Если реализация объявлена в классе\ $C$, то породить инструкцию $Put_1(mid)$, 
        где $mid$ --- идентификатор реализации;
        #. Иначе породить инструкцию $Put_2(tid,mid)$, где $tid$ и $mid$ --- идентификаторы
        супертипа, в котором объявлена реализация, и реализации в этом типе;
        #. Увеличить $cur \gets cur + 1$.

    #. Иначе увеличить $k \gets k + 1$.

\End{algorithm}

\Begin{algorithm}{alg:decoding} Восстановление\ $vmt_C$.

#. Инициализировать $cur \gets 0$;
#. Если у класса\ $C$ есть суперкласс, то скопировать его VMT в начало $vmt_C$;
#. Пока остались необработанные инструкции:
    #. Если следующая инструкция --- $Skip(k)$, то увеличить $cur \gets cur + k$;
    #. Если следующая инструкция --- $Put_1(mid)$, то:
        #. Инициализировать ячейку по индексу $cur$ адресом метода $mid$ в классе\ $C$;
        #. Увеличить $cur \gets cur + 1$.
    #. Если следующая инструкция --- $Put_2(tid,mid)$, то:
        #. Инициализировать ячейку по индексу $cur$ адресом метода $mid$ в 
        супертипе $tid$;
        #. Увеличить $cur \gets cur + 1$.

\End{algorithm}

Для полученного кодирования справедлива следующая теорема.

\Begin{theorem}\label{stmt:encoding-size} Если у класса не более $2^5$ предков
и в каждом из них, включая сам класс, не более $2^{21}$ методов, то при разностном 
кодировании VMT этого класса на 32-битной архитектуре размер закодированного 
представления не превосходит размера исходной таблицы.
\End{theorem}

\Begin{proof} Достаточно показать, что для каждой ячейки (или последовательности 
ячеек), соответствующая инструкция кодируется не более чем четыремя байтами в
кодировке Unsigned LEB128. В этой кодировке каждый байт закодированного представления
содержит 7 значащих бит.
Заметим, что размер инструкции\ $Skip(k)$ всегда строго меньше
кодируемой последовательности ячеек (в худшем случае, когда $k = 1$, инструкция
кодируется одним байтом), а также, что *Код* инструкции занимает два бита.

Условия теоремы гарантируют, что $tid < 2^5$ и $mid < 2^{21}$, а значит кодируются
5-ю и 21-м битом соответственно. Тогда вместе с *Кодом* инструкция\ $Put_1(mid)$
представляется 23-битным числом, которое кодируется не более чем четыремя байтами в
Unsigned LEB128. Инструкция\ $Put_2(tid,mid)$ имеет два аргумента, которые вместе
с *Кодом* занимают 7 и 21 бит соответственно. В кодировке Unsigned LEB128 первый
аргумент всегда занимает один байт, а второй аргумент --- не более трех байт.
\End{proof}

\pagebreak
# Экспериментальные результаты {#sec:results}

Оба алгоритма совмещенной раскладки и разностного кодирования таблиц были реализованы
в экспериментальной сборке Huawei JDK с поддержкой статической компиляции для
32-битной платформы ARMv7. Набор тестируемых приложений состоит из стандартных
библиотек и сред исполнения четырех языков программирования, перечисленных в 
таблице\ [-@tbl:test-apps]. Каждая библиотека была скомпилирована
статическим компилятором Huawei JDK. Помимо итогового алгоритма совмещенной раскладки, были 
протестированы также базовая раскладка и существующие подходы Marmot и SHAP:

- *Base* --- базовая раскладка ([@fig:base-vmt-layout]);
- *Combined* --- совмещенная раскладка ([@fig:last-imt-layout]);
- *Marmot* --- оригинальная раскладка IMT из Marmot;
- *SHAP* --- оригинальная раскладка IMT из SHAP.

<!-- Помимо итогового алгоритма совмещенной раскладки, протестированы все 
промежуточные раскладки, описанные в работе, а также несколько существующих подходов:

- *Base* --- базовая раскладка ([@fig:base-vmt-layout]);
- *VMT--IMT* --- совмещение VMT--IMT ([@fig:vmt-imt-layout]);
- *IMT--IMT* --- совмещение VMT--IMT и IMT--IMT ([@fig:imt-imt-layout]);
- *Combined* --- финальная совмещенная раскладка с расширением последней IMT 
суперкласса ([@fig:last-imt-layout]);
- *Marmot$^\ast$* --- совмещение VMT--IMT вместе с включением всех IMT, как в Marmot;
- *Marmot* --- оригинальная раскладка IMT из Marmot;
- *SHAP* --- оригинальная раскладка IMT из SHAP (Marmot$^\ast$ с дополнительными 
заголовками в IMT). -->

<!-- \Begin{landscape}

| Приложение          | VMT--IMT | IMT--IMT | Combined | Marmot$^\ast$ | Marmot | SHAP |
|:--------------------|---------:|---------:|---------:|--------------:|-------:|-----:| 
| scala-2.13.0        | **0.83** |    0.41  | **0.40** |   0.69        |  0.86  | ???  |
| jre-1.8.0_282 (cp1) |   0.42   |    0.24  | **0.17** |   0.24        |  0.82  | ???  |
| jruby-9.1.8.0       |   0.05   |    0.03  | **0.03** |   0.03        |  0.98  | ???  |
| kotlinc-1.1.0       |   0.57   |    0.33  | **0.31** |   0.41        |  0.84  | ???  |

: Коэффициент уменьшения ($<1$) или увеличения ($>1$) избыточности {#tbl:duplication-reduction}

\End{landscape} -->


+----------------------+-------------------+------------------------------+
| Язык                 | Количество классов| Размер исполняемого файла    |
|                      | и интерфейсов     | стандартной библиотеки, KB   |
+:=====================+==================:+=============================:+
| Kotlin 1.4.32        | 2 518             | 2 171                        |
+----------------------+-------------------+------------------------------+
| Groovy 3.0.8         | 4 891             | 4 845                        |
+----------------------+-------------------+------------------------------+
| Scala 2.13.0         | 2 587             | 5 174                        |
+----------------------+-------------------+------------------------------+
| Java 1.8.0_282 (cp1) | 6 500             | 10 285                       |
+----------------------+-------------------+------------------------------+

: Тестируемые языки и их стандартные библиотеки {#tbl:test-apps}

В таблице [-@tbl:duplication-reduction] представлены коэффициенты уменьшения
избыточности в таблицах, по сравнению с базовым алгоритмом раскладки. Использование
совмещенной раскладки таблиц позволяет удалить более\ 60\ % избыточности на всех
тестируемых приложениях, показывая лучшие результаты, чем существующие алгоритмы.
Подходу Marmot удается удалить до\ 21\ % избыточности только за счет совмещения IMT, 
а подходу SHAP --- еще улучшить этот результат на трех из четырех приложений 
за счет совмещения ячеек VMT и IMT.

| Язык                 | Base | Combined | Marmot | SHAP  |
|:---------------------|-----:|---------:|-------:|------:| 
| Kotlin 1.4.32        | 1.00 | **0.25** |  0.79  | 0.79  |
| Groovy 3.0.8         | 1.00 | **0.04** |  0.81  | 0.23  |
| Scala 2.13.0         | 1.00 | **0.40** |  0.86  | 0.73  |
| Java 1.8.0_282 (cp1) | 1.00 | **0.17** |  0.82  | 0.51  |

: Коэффициент уменьшения ($<1$) или увеличения ($>1$) избыточности таблиц стандартной библиотеки {#tbl:duplication-reduction}

В таблице [-@tbl:total-size-layout] отражены значения
размера исполняемого файла приложения, вместе с указанным
в скобках коэффициентом уменьшения относительно схемы базовой раскладки таблиц.

На всех приложениях снижение избыточности VMT и IMT влечет уменьшение размера
исполняемого файла. Однако, интересно отметить, что на приложениях с наибольшим 
снижением избыточности таблиц, написанных на Kotlin, Groovy и Java, получилось
наименьшее уменьшение размера исполняемого файла, в то время как размер приложения,
написанного на Scala, уменьшился значительно, несмотря на меньшее относительное
снижение избыточности. Это объясняется тем, что стандартная библиотека языка
Scala имеет богатую иерархию коллекций, основанную на довольно крупных интерфейсах,
из-за чего таблицы виртуальных и интерфейсных методов занимают почти\ 40\ % всего
исполняемого файла.

| Язык                 | Base          | Combined         | Marmot         | SHAP          |
|:---------------------|--------------:|-----------------:|---------------:|--------------:|
| Kotlin 1.4.32        |  2 171 (1.00) |   2 128 (0.98)   |  2 159 (0.99)  |  2 159 (0.99) |
| Groovy 3.0.8         |  4 845 (1.00) |   4 726 (0.98)   |  4 821 (1.00)  |  4 750 (0.98) |
| Scala 2.13.0         |  5 174 (1.00) | **4 263 (0.82)** |  4 961 (0.96)  |  4 769 (0.92) |
| Java 1.8.0_282 (cp1) | 10 285 (1.00) |  10 211 (0.99)   | 10 269 (1.00)  | 10 242 (1.00) |

: Размер исполняемого файла стандартной библиотеки (без кодирования), KB {#tbl:total-size-layout}

Результаты применения разностного кодирования к каждой из рассматриваемых раскладок
представлены в таблице\ [-@tbl:total-size-encoding]. Видно, что кодирование таблиц
существенно уменьшает размер метаданных, даже с самым базовым алгоритмом раскладки.
Более компактные раскладки также положительно влияют на сжатие закодированного представления.

| Язык                  | Base           | Combined       | Marmot         | SHAP           |
|:----------------------|---------------:|---------------:|---------------:|---------------:|
| Kotlin 1.4.32         |  2 048 (0.94)  |  2 043 (0.94)  |  2 046 (0.94)  |  2 045 (0.94)  |
| Groovy 3.0.8          |  4 295 (0.89)  |  4 286 (0.88)  |  4 294 (0.89)  |  4 287 (0.88)  |
| Scala 2.13.0          |**3 497 (0.68)**|**3 424 (0.66)**|**3 490 (0.67)**|**3 471 (0.67)**|
| Java 1.8.0_282 (cp1)  |  9 956 (0.97)  |  9 940 (0.97)  |  9 951 (0.97)  |  9 943 (0.97)  |

: Размер исполняемого файла стандартной библиотеки (c кодированием), KB {#tbl:total-size-encoding}

\clearpage
\pagebreak
# Заключение {#sec:conclusion -}

В настоящей работе были получены следующие результаты:

1. Разработан алгоритм совмещенной раскладки таблиц с гарантированной верхней
оценкой размера таблиц, позволяющий добиться 
значительного уменьшения дублирования данных в таблицах. Получено существенное
уменьшение размера исполняемого файла на диске.

1. Разработан алгоритм разностного кодирования, позволяющий значительно уменьшить
размер исполняемого файла, и при этом, эффективно восстановить исходную структуру
таблиц виртуальных и интерфейсных методов во время исполнения.

1. Продемонстрирована применимость разностного кодирования при произвольном
алгоритме раскладки таблиц.

1. Доказано, что размер закодированного представления таблиц с помощью разностного 
кодирования не превосходит исходного размера кодируемых данных при реалистичных 
ограничениях на количество типов и методов в программе.

1. Оба разработанных алгоритма были реализованы в экспериментальной сборке 
Huawei JDK и апробированы на представительном наборе приложений.

1. Доказана неограниченность размера таблиц при использовании существующей раскладки
таблиц в Marmot, по сравнению с базовым алгоритмом раскладки таблиц.

Для разработанных алгоритмов доказана только верхняя оценка размера таблиц и
закодированного представления, однако, она не дает понимания эффективности сжатия
на практике. Известно, что подход Marmot может давать более компактную раскладку,
несмотря на отсутствие верхней оценки размера таблиц, что задает направления
для дальнейших исследований в области раскладки интерфейсных таблиц. Также, имея
всего три инструкци разностного кодирования, предложенный подход демонстрирует
весьма положительные результаты, но оставляет свободу для расширения набора
инструкций и кодируемых метаданных.

\pagebreak
# Публикации автора по теме диссертации {-}

**Статьи:**

1. Trepakov\ I., Pavlov\ P. Compact Interface Method Table Layout // 2020 Ivannikov
Memorial Workshop (IVMEM). IEEE, 2020. Сс.\ 62--68.

**Свидетельства о государственной регистрации программы для ЭВМ:**

2. Свидетельство о государственной регистрации программы для ЭВМ №2017613872. 
Excelsior JET Embedded 11.3 for Linux/ARM\ / А.Л.\ Гигуз и др. -- Заявка №2016663925. 
Дата регистрации 19 декабря 2016 г. Дата публикации 3 апреля 2017 г.

**Патентные заявки:**

3. Заявка PCT/RU2020/000406. Application Service Metadata Encoding and 
Initialization\ / И.С.\ Трепаков, П.Е.\ Павлов; заявитель Huawei Technologies Co., Ltd.;
заявл. 03.08.2020.

**Тезисы докладов:**

4. Трепаков\ И.С. Эффективная реализация таблиц виртуальных методов в языках с 
поддержкой ограниченного множественного наследования // Материалы\ 56\-й
Международной научной студенческой конференции МНСК-2018: Математика. 2018. С.\ 183.

5. Трепаков\ И.С. Эффективная генерация служебных метаданных для таблиц
виртуальных методов в статических компиляторах // Материалы\ 58\-й Международной 
научной студенческой конференции МНСК-2020: Математика. 2020. С.\ 133.

\pagebreak
# Список использованных источников {-}

<div id="refs"></div>

<!-- \renewcommand{\thesection}{П}
\setcounter{subsection}{0}
\setcounter{figure}{0}
\setcounter{lstlisting}{0}
\pagebreak
# Приложение {#sec:appendix -}

## Особенности полиморфных вызовов в Java

\todo{}

### Область видимости методов

\todo{}

### Процедура разрешения

\todo{}

## Алгоритм совмещенной раскладки таблиц для Java

\todo{}

## Расширение разностного кодирования для Java

\todo{} -->
